Jun 8, 2009:
Using pygame to set up a basic drawing area and World instance.
Have a Unit moving back and forth across the empty screen.

New main classes: World, World.Pos, Unit
Testclass: Stupid(Unit)

Todays reading (excluding API lookups):
Pygame documentation
Python metaclasses

Jun 10, 2009:
Setting up algebra for python. Looking into NumPy package

Jun 11, 2009:
Improved Position class (separated from World)

Jun 12, 2009:
Put Position class into separate file
Working targetsystem for Units (World moves units according to their decisions)
Created RandomWalker Unit to walk around randomly. (demo)
Created Bouncer Unit to walk back and forth. (demo)
Rendering of path to target
Still no collision detection, but sketched up some ideas:
	(for optimization)First check if the rectangle that a unit moves through intersects a rectangle from another units movement
	 If so, do a robust check to see if, and with what force the units collide and record this data. 
	 Should also move units apart where they collide (i.e. not be possible to move through other units)
For system performance check, a simple FPS viewer is available. It needs some improvement though :
	Average over time to account for big differences with short iteration times

Jun 13, 2009:
Exchanged own Position class for Pygame inofficial vec2d-class which is more python-complete and well tested

Jun 15, 2009:
Ideas:
Planning, Physics, Rendering could be different modules
But planning and physics would probably have to be synchronized/same thread to give repeatable results

Jun 16, 2009:
Reading more python docs. Using itertools

Jun 17, 2009:
Refactoring design pattern to have better data encapsulation and protection.

Jun 23, 2009:
Rethinking Unit/Intelligence/Physics design pattern.
Intelligence should not be able to directly set the position or other properties controlled by the physics engine directly.
As a result of this, the data passed to the intelligence should either be copies of the internal data, or immutable versions of the same (the latter is hard to achieve).
In short: the internal datastructure holding physical properties of the object should never be exposed to the intelligence. In python, complete data security is practically impossible, but it should at least be apparent that physical properties should not be altered directly.
Options:
#1 Having a Unit class that contains both physical properties, intelligence and unit drawing. Creating a deep copy of the instance before calling the "think()"-method on the newly created instance, securing any data in the internal Unit-class for the physics engine to use.
This still exposes a "fake" unit to the intelligence.
	Pos: Everything about a unit is packaged together 
	Neg: Thinking object (Unit) is not retained between think()-calls, making it hard to save data between calls.
#2 Having separate Unit and Intelligence objects for each thinking entity. Physics data sent as argument to Intelligence when calling think()
	Pos: The Intelligence instance can be retained between calls. More apparent that physics data are read-only.
	Neg: Added complexity to the system. More code.
	
On second thought option #2 seems to be by far the best looking and structurally correct option, so I will go with that.

Physics state:
Should unit state (i.e position, velocity, forces etc.) be encapsulated even further? Allowing physics model to be changed to using matrix oprations rather than multiple vectors.
Should this state be encapsulated in the Unit class or in another structure owned or inherited by the Unit class?
Created State class for benchmarking numpy array,matrix vs. pygame inofficial vec2d. Numpy matrix was slower, numpy array was faster (when should you ever use matrix?)

Summary of plan:
Unit - View in MVC pattern, holds informations such as a units color and drawing code (which gets access to physical state too when drawing).
State - Model in MVC pattern, holds physical properties of object that in any way affects how the physics engine works on the object.
	Optionally: PublicState - Special state object that exposes only certain physical properties for other parts than the physics engine to see
Intelligence - Controller in MVC Pattern. Has the think(WorldData data) method that takes certain public properties of the rest of world as a parameter, and can issue orders of changed behaviour for the object to the physics engine.

Engine step:
So far the engine has been coded like a game: Draw frames as fast as possible and maintain real time syncronisation.
For scientific purposes, this is not optimal - the results will vary depending on the hardware where the system is run.
A better aproach would be to emulate a fixed framerate and send in the same time step for every frame. This way, the system will run equivalently every time (except if seeded "random" is used) allowing exact repeatability - the basis for empirical science. How this time step is determined is not very important, but could be chosen in a way that makes real-time display of simulations go at a pleasant speed. Also, collision detection could be made much simpler by choosing a small enough time step so that objects never can "pass" each other by accident and a simple bounding box/radius-comparison will suffice for basic collision detection.

Jun 29, 2009:
C++ physics module written and added to projekt to allow fast simulations even with many units.
Ai will still be written in python for simplicity, and possibly ported to C++ if performance is not sufficient.
think() is supplied a tuple containing all particles within a units range
