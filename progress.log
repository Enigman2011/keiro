Jun 8, 2009:
Using pygame to set up a basic drawing area and World instance.
Have a Unit moving back and forth across the empty screen.

New main classes: World, World.Pos, Unit
Testclass: Stupid(Unit)

Todays reading (excluding API lookups):
Pygame documentation
Python metaclasses

Jun 10, 2009:
Setting up algebra for python. Looking into NumPy package

Jun 11, 2009:
Improved Position class (separated from World)

Jun 12, 2009:
Put Position class into separate file
Working targetsystem for Units (World moves units according to their decisions)
Created RandomWalker Unit to walk around randomly. (demo)
Created Bouncer Unit to walk back and forth. (demo)
Rendering of path to target
Still no collision detection, but sketched up some ideas:
	(for optimization)First check if the rectangle that a unit moves through intersects a rectangle from another units movement
	 If so, do a robust check to see if, and with what force the units collide and record this data. 
	 Should also move units apart where they collide (i.e. not be possible to move through other units)
For system performance check, a simple FPS viewer is available. It needs some improvement though :
	Average over time to account for big differences with short iteration times

Jun 13, 2009:
Exchanged own Position class for Pygame inofficial vec2d-class which is more python-complete and well tested

Jun 15, 2009:
Ideas:
Planning, Physics, Rendering could be different modules
But planning and physics would probably have to be synchronized/same thread to give repeatable results

Jun 16, 2009:
Reading more python docs. Using itertools

Jun 17, 2009:
Refactoring design pattern to have better data encapsulation and protection.

Jun 23, 2009:
Rethinking Unit/Intelligence/Physics design pattern.
Intelligence should not be able to directly set the position or other properties controlled by the physics engine directly.
As a result of this, the data passed to the intelligence should either be copies of the internal data, or immutable versions of the same (the latter is hard to achieve).
In short: the internal datastructure holding physical properties of the object should never be exposed to the intelligence. In python, complete data security is practically impossible, but it should at least be apparent that physical properties should not be altered directly.
Options:
#1 Having a Unit class that contains both physical properties, intelligence and unit drawing. Creating a deep copy of the instance before calling the "think()"-method on the newly created instance, securing any data in the internal Unit-class for the physics engine to use.
This still exposes a "fake" unit to the intelligence.
	Pos: Everything about a unit is packaged together 
	Neg: Thinking object (Unit) is not retained between think()-calls, making it hard to save data between calls.
#2 Having separate Unit and Intelligence objects for each thinking entity. Physics data sent as argument to Intelligence when calling think()
	Pos: The Intelligence instance can be retained between calls. More apparent that physics data are read-only.
	Neg: Added complexity to the system. More code.
	
On second thought option #2 seems to be by far the best looking and structurally correct option, so I will go with that.

Physics state:
Should unit state (i.e position, velocity, forces etc.) be encapsulated even further? Allowing physics model to be changed to using matrix oprations rather than multiple vectors.
Created State class for benchmarking numpy array,matrix vs. pygame inofficial vec2d. Numpy matrix was slower, numpy array was faster (when should you ever use matrix?)




