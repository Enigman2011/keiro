Jun 8, 2009:
Using pygame to set up a basic drawing area and World instance.
Have a Unit moving back and forth across the empty screen.

New main classes: World, World.Pos, Unit
Testclass: Stupid(Unit)

Todays reading (excluding API lookups):
Pygame documentation
Python metaclasses

Jun 10, 2009:
Setting up algebra for python. Looking into NumPy package

Jun 11, 2009:
Improved Position class (separated from World)

Jun 12, 2009:
Put Position class into separate file
Working targetsystem for Units (World moves units according to their decisions)
Created RandomWalker Unit to walk around randomly. (demo)
Created Bouncer Unit to walk back and forth. (demo)
Rendering of path to target
Still no collision detection, but sketched up some ideas:
	(for optimization)First check if the rectangle that a unit moves through intersects a rectangle from another units movement
	 If so, do a robust check to see if, and with what force the units collide and record this data. 
	 Should also move units apart where they collide (i.e. not be possible to move through other units)
For system performance check, a simple FPS viewer is available. It needs some improvement though :
	Average over time to account for big differences with short iteration times

Jun 13, 2009:
Exchanged own Position class for Pygame inofficial vec2d-class which is more python-complete and well tested

Jun 15, 2009:
Ideas:
Planning, Physics, Rendering could be different modules
But planning and physics would probably have to be synchronized/same thread to give repeatable results

Jun 16, 2009:
Reading more python docs. Using itertools

Jun 17, 2009:
Refactoring design pattern to have better data encapsulation and protection.

